<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas - Ultra Glow Edition</title>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', sans-serif;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        #ui-layer {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        .guide {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #FFD700;
            font-weight: bold;
            letter-spacing: 1px;
        }

        button {
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(to bottom, #D32F2F, #8B0000);
            color: #FFF;
            border: 2px solid #FFD700;
            padding: 15px 50px;
            border-radius: 30px;
            font-weight: 800;
            font-size: 16px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
            animation: pulse 1.5s infinite;
            text-transform: uppercase;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 0 40px rgba(255, 0, 0, 0.8);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            }
        }

        #camera-preview {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 120px;
            height: 90px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            transform: scaleX(-1);
            opacity: 0.8;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        #copyright {
            position: absolute;
            bottom: 10px;
            right: 15px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            z-index: 100;
            font-family: sans-serif;
            pointer-events: none;
            font-style: italic;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>
    <div id="ui-layer">
        <div class="guide">üñê Open: Explode | ü´∂ Heart: Love | ‚úä Fist: Tree</div>
        <button id="btnStart" onclick="window.startSystem()">START MAGIC</button>
    </div>
    <div id="copyright">¬© by vandiep</div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- CONFIG ---
        const CONFIG = {
            totalParticles: 1200, // TƒÉng s·ªë l∆∞·ª£ng l√™n ch√∫t cho ƒë·∫πp
            explodeRadius: 65,
            photoOrbitRadius: 30,
            treeHeight: 65,
            treeBaseRadius: 30
        };

        let scene, camera, renderer, composer;
        let particleGroup;
        let meshParticles = [];
        let photoMeshes = [];
        let titleMesh, starMesh, loveMesh, topStar3D;
        let magicDustTrail = null;
        let candyCaneTexture, magicDustTexture;

        // State variables
        let state = 'TREE';
        let selectedIndex = 0;
        let handX = 0.5;
        let explodeRotationY = 0;
        let hasHandDetected = false;

        // Resources
        const photoTextures = [];
        const loader = new THREE.TextureLoader();
        ['./images/image1.jpeg', './images/image2.jpeg', './images/image3.jpeg', './images/image4.jpeg', './images/image5.jpeg'].forEach(url => {
            photoTextures.push(loader.load(url));
        });
        const music = new Audio('./audio.mp3');
        music.loop = true;

        // --- TEXTURE GENERATORS ---
        function createCandyCaneTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            for (let i = 0; i < 16; i++) {
                ctx.fillStyle = (i % 2 === 0) ? '#FFFFFF' : '#D32F2F';
                ctx.fillRect(0, i * 16, 64, 16);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.colorSpace = THREE.SRGBColorSpace; // Quan tr·ªçng cho m√†u ƒë·∫πp
            return tex;
        }

        function createMagicDustTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(32, 32, 0, 32, 32, 30);
            grd.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grd.addColorStop(0.4, 'rgba(255, 215, 0, 0.8)');
            grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        // --- INIT SYSTEM ---
        function init3D() {
            candyCaneTexture = createCandyCaneTexture();
            magicDustTexture = createMagicDustTexture();

            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505); // N·ªÅn ƒëen tuy·ªÅn h∆°i x√°m nh·∫π ƒë·ªÉ ƒë·ª° g·∫Øt
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 100);

            // 1. RENDERER M·ªöI (Tone Mapping & Exposure cao)
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.5; // TƒÉng ƒë·ªô ph∆°i s√°ng ƒë·ªÉ r·ª±c r·ª°
            container.appendChild(renderer.domElement);

            // 2. M√îI TR∆Ø·ªúNG (ROOM ENVIRONMENT) - Ch√¨a kh√≥a cho ƒë·ªô b√≥ng
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            // 3. POST-PROCESSING (BLOOM) - Ch√¨a kh√≥a cho h√†o quang
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.6; // Ng∆∞·ª°ng s√°ng ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√°t s√°ng
            bloomPass.strength = 0.5;  // ƒê·ªô m·∫°nh h√†o quang
            bloomPass.radius = 0.4;

            const outputPass = new OutputPass(); // X·ª≠ l√Ω m√†u s·∫Øc cu·ªëi c√πng

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(outputPass);

            // 4. √ÅNH S√ÅNG (LIGHTS) - M·∫°nh h∆°n, dramatic h∆°n
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // ƒê√®n v√†ng t√¢m c√¢y (ƒë·ªÉ c√¢y s√°ng t·ª´ trong ra)
            const innerLight = new THREE.PointLight(0xffaa00, 5.0, 50);
            innerLight.position.set(0, 10, 0);
            scene.add(innerLight);

            // ƒê√®n chi·∫øu ch√≠nh (Spotlight Gold)
            const spotGold = new THREE.SpotLight(0xffd700, 2000); // Intensity r·∫•t cao cho PBR
            spotGold.position.set(50, 80, 50);
            spotGold.angle = 0.5;
            spotGold.penumbra = 0.5;
            scene.add(spotGold);

            // ƒê√®n vi·ªÅn xanh (Rim light) t·∫°o chi·ªÅu s√¢u
            const spotBlue = new THREE.SpotLight(0x0044ff, 1000);
            spotBlue.position.set(-50, 50, -50);
            scene.add(spotBlue);

            // --- OBJECTS ---
            createParticles();
            createTopStar();
            createPhotos();
            createMagicDustTrail();
            createDecorations();

            animate();
        }

        // --- CREATION FUNCTIONS ---
        function createTopStar() {
            const geo = new THREE.OctahedronGeometry(4, 0);
            const mat = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                emissive: 0xffaa00,
                emissiveIntensity: 2.0, // T·ª± ph√°t s√°ng m·∫°nh
                metalness: 1.0,
                roughness: 0.2
            });
            topStar3D = new THREE.Mesh(geo, mat);
            topStar3D.position.set(0, CONFIG.treeHeight / 2 + 2, 0);
            scene.add(topStar3D);
        }

        function createParticles() {
            particleGroup = new THREE.Group();
            scene.add(particleGroup);
            meshParticles = [];

            // Geometry d√πng chung ƒë·ªÉ t·ªëi ∆∞u
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const sphereGeo = new THREE.SphereGeometry(0.6, 16, 16);

            // Materials PBR x·ªãn
            const greenMat = new THREE.MeshStandardMaterial({ color: 0x0a4a0a, roughness: 0.8, metalness: 0.2 });
            const goldBoxMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 1.0, envMapIntensity: 1.0 });
            const goldSphereMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, roughness: 0.1, metalness: 1.0, envMapIntensity: 1.5 });
            const redMat = new THREE.MeshPhysicalMaterial({ color: 0xcc0000, metalness: 0.4, roughness: 0.2, clearcoat: 1.0, clearcoatRoughness: 0.1 }); // B√≥ng nh∆∞ nh·ª±a c·ª©ng

            // K·∫πo g·∫≠y
            const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1.5, 0), new THREE.Vector3(0.5, 2, 0)]);
            const caneGeo = new THREE.TubeGeometry(curve, 8, 0.15, 8, false);
            const caneMat = new THREE.MeshStandardMaterial({ map: candyCaneTexture, roughness: 0.5 });

            for (let i = 0; i < CONFIG.totalParticles; i++) {
                let mesh, type;
                const r = Math.random();

                if (r < 0.4) { type = 'leaf'; mesh = new THREE.Mesh(boxGeo, greenMat); mesh.scale.setScalar(0.5 + Math.random() * 0.5); }
                else if (r < 0.65) { type = 'goldBox'; mesh = new THREE.Mesh(boxGeo, goldBoxMat); mesh.scale.setScalar(0.4 + Math.random() * 0.4); }
                else if (r < 0.85) { type = 'goldSphere'; mesh = new THREE.Mesh(sphereGeo, goldSphereMat); mesh.scale.setScalar(0.5 + Math.random() * 0.5); }
                else if (r < 0.95) { type = 'redSphere'; mesh = new THREE.Mesh(sphereGeo, redMat); mesh.scale.setScalar(0.6 + Math.random() * 0.4); }
                else { type = 'cane'; mesh = new THREE.Mesh(caneGeo, caneMat); mesh.scale.setScalar(1 + Math.random()); }

                // T√≠nh v·ªã tr√≠ Tree (H√¨nh n√≥n xo·∫Øn ·ªëc)
                const h = Math.random() * CONFIG.treeHeight;
                const y = h - CONFIG.treeHeight / 2;
                const rRatio = (1 - h / CONFIG.treeHeight);
                const maxR = rRatio * CONFIG.treeBaseRadius;
                // Gom l√° v√†o trong, qu·∫£ ch√¢u ra ngo√†i ch√∫t
                const radius = (type === 'leaf') ? (Math.random() * maxR) : (maxR * (0.8 + Math.random() * 0.2));
                const angle = Math.random() * Math.PI * 2;
                const treePos = new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius);

                // T√≠nh v·ªã tr√≠ Explode
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const exR = CONFIG.explodeRadius * Math.cbrt(Math.random());
                const explodePos = new THREE.Vector3(exR * Math.sin(phi) * Math.cos(theta), exR * Math.sin(phi) * Math.sin(theta), exR * Math.cos(phi));

                // T√≠nh v·ªã tr√≠ Heart
                const tH = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(tH), 3);
                let hy = 13 * Math.cos(tH) - 5 * Math.cos(2 * tH) - 2 * Math.cos(3 * tH) - Math.cos(4 * tH);
                hx *= 2.0; hy *= 2.0;
                const heartPos = new THREE.Vector3(hx, hy + 5, (Math.random() - 0.5) * 10);

                mesh.position.copy(treePos);
                mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);

                particleGroup.add(mesh);
                meshParticles.push({ mesh, type, treePos, explodePos, heartPos, rotSpeed: new THREE.Vector3((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02) });
            }
        }

        function createMagicDustTrail() {
            const count = 300;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const speeds = [], phases = [];

            for (let i = 0; i < count; i++) {
                pos[i * 3] = (Math.random() - 0.5) * 10;
                pos[i * 3 + 1] = -CONFIG.treeHeight / 2;
                pos[i * 3 + 2] = (Math.random() - 0.5) * 10;
                sizes[i] = Math.random();
                speeds.push(0.05 + Math.random() * 0.1);
                phases.push(Math.random() * Math.PI * 2);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geo.userData = { speeds, phases };

            const mat = new THREE.PointsMaterial({
                map: magicDustTexture,
                color: 0xffaa00,
                transparent: true, opacity: 0.8,
                size: 1.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            magicDustTrail = new THREE.Points(geo, mat);
            scene.add(magicDustTrail);
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(8, 8);
            const frameGeo = new THREE.PlaneGeometry(9, 9);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1.0, roughness: 0.2 });

            photoTextures.forEach((tex, i) => {
                tex.colorSpace = THREE.SRGBColorSpace;
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                const frame = new THREE.Mesh(frameGeo, frameMat);
                frame.position.z = -0.1;
                mesh.add(frame);
                mesh.visible = false;
                scene.add(mesh);
                photoMeshes.push(mesh);
            });
        }

        function createDecorations() {
            // Text Canvas Helper
            function createTextSprite(text, size, color, glow) {
                const canvas = document.createElement('canvas');
                canvas.width = 1024; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.font = `bold italic ${size}px "Times New Roman"`;
                ctx.fillStyle = color; ctx.textAlign = 'center';
                ctx.shadowColor = glow; ctx.shadowBlur = 40;
                ctx.fillText(text, 512, 160);
                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending });
                return new THREE.Sprite(mat);
            }

            titleMesh = createTextSprite("MERRY CHRISTMAS", 100, '#FFD700', '#FF0000');
            titleMesh.position.set(0, CONFIG.treeHeight / 2 + 15, 0);
            titleMesh.scale.set(60, 15, 1);
            scene.add(titleMesh);

            loveMesh = createTextSprite("I LOVE YOU ‚ù§Ô∏è", 120, '#FF69B4', '#FF1493');
            loveMesh.position.set(0, 0, 20);
            loveMesh.scale.set(70, 18, 1);
            loveMesh.visible = false;
            scene.add(loveMesh);
        }

        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            // 1. Particle Logic
            let targetPosName = (state === 'TREE') ? 'treePos' : (state === 'HEART' ? 'heartPos' : 'explodePos');
            const speed = (state === 'EXPLODE') ? 0.03 : 0.08;

            meshParticles.forEach(p => {
                // Move
                p.mesh.position.lerp(p[targetPosName], speed);
                // Rotate
                if (state === 'EXPLODE') {
                    p.mesh.rotation.x += p.rotSpeed.x;
                    p.mesh.rotation.y += p.rotSpeed.y;
                } else {
                    p.mesh.rotation.set(0, 0, 0); // Tree/Heart ƒë·ª©ng y√™n s·∫Ω g·ªçn h∆°n
                }
                // Blink emissive
                if (p.mesh.material.emissive) {
                    const intensity = 0.5 + 0.5 * Math.sin(time * 5 + p.mesh.id);
                    p.mesh.material.emissiveIntensity = intensity;
                }
            });

            // 2. Global Rotation
            if (state === 'TREE') {
                particleGroup.rotation.y += 0.005;
                titleMesh.visible = true; loveMesh.visible = false;
                if (magicDustTrail) magicDustTrail.visible = true;
                topStar3D.visible = true;
                photoMeshes.forEach(m => m.visible = false);
            } else if (state === 'HEART') {
                particleGroup.rotation.y = 0;
                const beat = 1 + Math.sin(time * 5) * 0.05;
                particleGroup.scale.set(beat, beat, beat);
                titleMesh.visible = false; loveMesh.visible = true;
                if (magicDustTrail) magicDustTrail.visible = false;
                topStar3D.visible = false;
            } else if (state === 'EXPLODE') {
                particleGroup.scale.set(1, 1, 1);
                titleMesh.visible = false; loveMesh.visible = false;
                if (magicDustTrail) magicDustTrail.visible = false;
                topStar3D.visible = false;

                // Hand control rotation
                if (hasHandDetected) {
                    explodeRotationY = (handX - 0.5) * Math.PI * 4;
                }
                particleGroup.rotation.y += (explodeRotationY - particleGroup.rotation.y) * 0.1;

                // Photos
                const radius = CONFIG.photoOrbitRadius;
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    // X·∫øp th√†nh v√≤ng tr√≤n
                    const angle = (i / photoMeshes.length) * Math.PI * 2 + particleGroup.rotation.y;
                    mesh.position.set(Math.sin(angle) * radius, Math.sin(time + i) * 2, Math.cos(angle) * radius);
                    mesh.lookAt(camera.position);
                    // Hi·ªáu ·ª©ng ph√≥ng to khi ·ªü g·∫ßn camera
                    const dist = mesh.position.distanceTo(camera.position);
                    const s = (dist < 40) ? 1.5 : 0.6;
                    mesh.scale.lerp(new THREE.Vector3(s, s, s), 0.1);
                });
            } else if (state === 'PHOTO') {
                // Zoom v√†o ·∫£nh ƒëang ch·ªçn (gi·∫£n l∆∞·ª£c: hi·ªán ·∫£nh ƒë·∫ßu ti√™n to ƒë√πng)
                photoMeshes.forEach((m, i) => {
                    if (i === 0) {
                        m.visible = true;
                        m.position.lerp(new THREE.Vector3(0, 0, 80), 0.1);
                        m.scale.set(4, 4, 4);
                        m.lookAt(camera.position);
                    } else m.visible = false;
                });
            }

            // 3. Magic Dust Update
            if (magicDustTrail && magicDustTrail.visible) {
                const pos = magicDustTrail.geometry.attributes.position.array;
                const spd = magicDustTrail.geometry.userData.speeds;
                const phs = magicDustTrail.geometry.userData.phases;
                for (let i = 0; i < 300; i++) {
                    let y = pos[i * 3 + 1];
                    y += spd[i];
                    if (y > CONFIG.treeHeight / 2) y = -CONFIG.treeHeight / 2;
                    pos[i * 3 + 1] = y;

                    // Xo·∫Øn ·ªëc
                    const rRatio = (y + CONFIG.treeHeight / 2) / CONFIG.treeHeight;
                    const r = (1 - rRatio) * (CONFIG.treeBaseRadius + 5);
                    const angle = time + phs[i] + y * 0.1;
                    pos[i * 3] = Math.cos(angle) * r;
                    pos[i * 3 + 2] = Math.sin(angle) * r;
                }
                magicDustTrail.geometry.attributes.position.needsUpdate = true;
            }

            // 4. Render with Composer (Bloom)
            composer.render();
        }

        // --- GLOBAL START ---
        window.startSystem = function () {
            document.getElementById('btnStart').style.display = 'none';
            music.play().catch(e => console.log("Click ƒë·ªÉ nghe nh·∫°c"));

            init3D();

            // MediaPipe Logic (Gi·ªØ nguy√™n logic c≈© nh∆∞ng ch·∫°y trong module n√†y)
            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');

            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

            hands.onResults(results => {
                ctx.save(); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.scale(-1, 1); ctx.translate(-canvas.width, 0);
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height); ctx.restore();

                if (results.multiHandLandmarks.length > 0) {
                    hasHandDetected = true;
                    const lm = results.multiHandLandmarks[0];
                    handX = lm[9].x; // C·∫≠p nh·∫≠t bi·∫øn to√†n c·ª•c ƒë·ªÉ xoay

                    // Logic chuy·ªÉn tr·∫°ng th√°i ƒë∆°n gi·∫£n
                    const thumb = lm[4], index = lm[8], wrist = lm[0];
                    const pinch = Math.hypot(thumb.x - index.x, thumb.y - index.y);
                    const tips = [lm[8], lm[12], lm[16], lm[20]];
                    let openDist = 0; tips.forEach(t => openDist += Math.hypot(t.x - wrist.x, t.y - wrist.y));
                    openDist /= 4;

                    if (openDist < 0.25) state = 'TREE'; // N·∫Øm tay
                    else if (pinch < 0.05) state = 'PHOTO'; // Ch·ª•m tay
                    else state = 'EXPLODE'; // M·ªü tay
                } else {
                    hasHandDetected = false;
                }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({ image: video }); },
                width: 320, height: 240
            });
            cameraUtils.start();
        }
    </script>
</body>

</html>