<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas Tree - Ultimate Edition</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #1B2838 0%, #090A0F 100%);
            font-family: 'Segoe UI', sans-serif;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        .guide {
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px black;
            letter-spacing: 1px;
        }

        button {
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(135deg, #D32F2F 0%, #8B0000 100%);
            color: #FFF;
            border: 2px solid #FFD700;
            padding: 15px 50px;
            border-radius: 30px;
            font-weight: 800;
            font-size: 16px;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.5), 0 0 80px rgba(255, 215, 0, 0.3);
            animation: pulse 2s infinite ease-in-out;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 0 40px rgba(255, 0, 0, 0.5);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 0 60px rgba(255, 0, 0, 0.7), 0 0 100px rgba(255, 215, 0, 0.5);
            }
        }

        /* Camera Preview */
        #camera-preview {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 150px;
            height: 112px;
            border: 2px solid rgba(255, 215, 0, 0.4);
            transform: scaleX(-1);
            opacity: 0.7;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* Stats Panel */
        #stats-panel {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: #888;
            z-index: 100;
            font-family: sans-serif;
            user-select: none;
        }

        #stats-panel .stat-label {
            font-size: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 4px;
            color: #555;
        }

        #stats-panel .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin: 0 0 15px 0;
        }

        #stats-panel .stat-value span {
            font-size: 10px;
            color: #555;
            font-weight: normal;
        }

        /* Copyright */
        #copyright {
            position: absolute;
            bottom: 10px;
            right: 15px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            z-index: 100;
            font-family: sans-serif;
            pointer-events: none;
            font-style: italic;
        }

        #error-log {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            color: red;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
            padding: 10px;
        }

        /* State indicator */
        #state-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 215, 0, 0.6);
            font-size: 12px;
            letter-spacing: 3px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }
    </style>
</head>

<body>
    <div id="error-log"></div>

    <!-- State Indicator -->
    <div id="state-indicator">üéÑ READY</div>

    <!-- Stats Panel -->
    <div id="stats-panel">
        <div>
            <p class="stat-label">Foliage Particles</p>
            <p class="stat-value" style="color: #00FF88;">15K <span>EMERALD NEEDLES</span></p>
        </div>
        <div>
            <p class="stat-label">Decorations</p>
            <p class="stat-value" style="color: #FFD700;">500+ <span>ORNAMENTS</span></p>
        </div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="guide">
            üñê <b>Open Palm:</b> Chaos &nbsp;|&nbsp; ‚úä <b>Fist:</b> Form Tree &nbsp;|&nbsp; ü´∂ <b>Heart:</b> Love Mode
        </div>
        <button id="btnStart" onclick="startSystem()">‚ú® START MAGIC ‚ú®</button>
    </div>

    <!-- Copyright -->
    <div id="copyright">¬© Ultimate Christmas Tree by Vandiep</div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
        // ==========================================
        // 1. CONFIGURATION
        // ==========================================
        const CONFIG = {
            colors: {
                emerald: 0x004225,      // M√†u l√° xanh ng·ªçc l·ª•c b·∫£o
                gold: 0xFFD700,
                silver: 0xECEFF1,
                red: 0xD32F2F,
                warmLight: 0xFFD54F,
                lights: [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF],
                giftColors: [0xD32F2F, 0xFFD700, 0x1976D2, 0x2E7D32]
            },
            counts: {
                foliage: 15000,    // S·ªë l∆∞·ª£ng l√° th√¥ng
                ornaments: 200,    // ƒê·ªì trang tr√≠
                lights: 300,       // ƒê√®n nh·∫•p nh√°y
                snowflakes: 500,   // Tuy·∫øt r∆°i
                stars: 3000        // Sao n·ªÅn
            },
            tree: {
                height: 70,
                radius: 35
            }
        };

        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL);
        bgMusic.loop = true; bgMusic.volume = 1.0;

        let scene, camera, renderer, composer;
        let foliageSystem, ornamentsGroup, lightsGroup, starMesh;
        let snowflakes = [];
        let state = 'CHAOS'; // CHAOS ho·∫∑c FORMED
        let handX = 0.5;
        let hasHandDetected = false;

        // ==========================================
        // 2. THREE.JS INITIALIZATION
        // ==========================================
        function init3D() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000308, 0.003);

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.5;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x003311, 0.5);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(CONFIG.colors.warmLight, 1.5, 200);
            pointLight1.position.set(50, 50, 50);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(CONFIG.colors.gold, 1, 150);
            pointLight2.position.set(-50, 20, -50);
            scene.add(pointLight2);

            // Create all elements
            createStarField();
            createFoliageSystem();
            createOrnaments();
            createFairyLights();
            createTopStar();
            createSnowfall();
            createMagicDust();

            animate();
        }

        // ==========================================
        // 3. STAR FIELD BACKGROUND
        // ==========================================
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = CONFIG.counts.stars;
            const positions = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);

            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
                sizes[i] = Math.random() * 2;
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        // ==========================================
        // 4. FOLIAGE SYSTEM (Emerald Tree)
        // ==========================================
        function createFoliageSystem() {
            const count = CONFIG.counts.foliage;
            const positions = new Float32Array(count * 3);
            const targetPositions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const phases = new Float32Array(count);

            // M√†u gradient t·ª´ xanh ƒë·∫≠m ·ªü d∆∞·ªõi l√™n xanh s√°ng ·ªü tr√™n
            const colorBottom = new THREE.Color(0x004225); // Emerald ƒë·∫≠m
            const colorMiddle = new THREE.Color(0x00FF88); // Xanh s√°ng
            const colorTop = new THREE.Color(0x88FFCC);    // Xanh ng·ªçc s√°ng

            for (let i = 0; i < count; i++) {
                // === V·ªã tr√≠ ban ƒë·∫ßu (CHAOS - h√¨nh c·∫ßu ng·∫´u nhi√™n) ===
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const chaosRadius = 60 + Math.random() * 30;

                positions[i * 3] = chaosRadius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = chaosRadius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = chaosRadius * Math.cos(phi);

                // === V·ªã tr√≠ ƒë√≠ch (FORMED - h√¨nh c√¢y th√¥ng xo·∫Øn ·ªëc) ===
                const spiralFactor = 0.15;
                const angle = i * spiralFactor;
                const h = (i / count) * CONFIG.tree.height;
                const y = h - CONFIG.tree.height / 2;

                // B√°n k√≠nh gi·∫£m d·∫ßn theo ƒë·ªô cao (h√¨nh n√≥n)
                const normalizedY = h / CONFIG.tree.height;
                const maxRadius = CONFIG.tree.radius * (1 - normalizedY * 0.95);

                // Th√™m variation cho ƒë·ªô d√†y
                const radiusVariation = 0.5 + Math.random() * 0.5;
                const r = maxRadius * radiusVariation;

                targetPositions[i * 3] = r * Math.cos(angle);
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = r * Math.sin(angle);

                // === M√†u gradient theo chi·ªÅu cao ===
                let color;
                if (normalizedY < 0.5) {
                    const t = normalizedY * 2;
                    color = colorBottom.clone().lerp(colorMiddle, t);
                } else {
                    const t = (normalizedY - 0.5) * 2;
                    color = colorMiddle.clone().lerp(colorTop, t);
                }

                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                sizes[i] = 1.5 + Math.random() * 1.5;
                phases[i] = Math.random() * Math.PI * 2;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            geometry.userData = {
                targetPositions: targetPositions,
                originalColors: new Float32Array(colors),
                phases: phases,
                velocities: new Float32Array(count * 3).fill(0)
            };

            // T·∫°o texture h·∫°t s√°ng
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.3, 'rgba(136, 255, 200, 0.8)');
            gradient.addColorStop(0.6, 'rgba(0, 66, 37, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            const texture = new THREE.CanvasTexture(canvas);

            const material = new THREE.PointsMaterial({
                size: 2,
                map: texture,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            foliageSystem = new THREE.Points(geometry, material);
            scene.add(foliageSystem);
        }

        // ==========================================
        // 5. ORNAMENTS (Decorations)
        // ==========================================
        function createOrnaments() {
            ornamentsGroup = new THREE.Group();
            const count = CONFIG.counts.ornaments;

            // Geometries
            const sphereGeo = new THREE.SphereGeometry(0.8, 16, 16);
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const coneGeo = new THREE.ConeGeometry(0.5, 1.2, 8);

            for (let i = 0; i < count; i++) {
                const type = Math.floor(Math.random() * 3);
                let geometry, color;

                if (type === 0) {
                    geometry = sphereGeo;
                    color = CONFIG.colors.giftColors[Math.floor(Math.random() * 4)];
                } else if (type === 1) {
                    geometry = boxGeo;
                    color = CONFIG.colors.gold;
                } else {
                    geometry = coneGeo;
                    color = Math.random() > 0.5 ? 0xD32F2F : 0xFFFFFF;
                }

                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.3,
                    metalness: 0.6,
                    emissive: color,
                    emissiveIntensity: 0.2
                });

                const mesh = new THREE.Mesh(geometry, material);

                // Chaos position
                mesh.userData.chaosPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );

                // Target position (on tree)
                const h = Math.random() * CONFIG.tree.height;
                const y = h - CONFIG.tree.height / 2;
                const normalizedY = h / CONFIG.tree.height;
                const radius = (CONFIG.tree.radius * (1 - normalizedY)) + 1;
                const theta = Math.random() * Math.PI * 2;

                mesh.userData.targetPos = new THREE.Vector3(
                    radius * Math.cos(theta),
                    y,
                    radius * Math.sin(theta)
                );

                mesh.userData.rotSpeed = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2,
                    z: (Math.random() - 0.5) * 2
                };

                mesh.position.copy(mesh.userData.chaosPos);
                mesh.scale.setScalar(0.5 + Math.random() * 0.5);

                ornamentsGroup.add(mesh);
            }

            scene.add(ornamentsGroup);
        }

        // ==========================================
        // 6. FAIRY LIGHTS
        // ==========================================
        function createFairyLights() {
            lightsGroup = new THREE.Group();
            const count = CONFIG.counts.lights;

            const sphereGeo = new THREE.SphereGeometry(0.3, 8, 8);

            for (let i = 0; i < count; i++) {
                const color = CONFIG.colors.lights[Math.floor(Math.random() * CONFIG.colors.lights.length)];

                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0,
                    transparent: true,
                    opacity: 0.9
                });

                const light = new THREE.Mesh(sphereGeo, material);

                // Chaos position
                light.userData.chaosPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 80,
                    (Math.random() - 0.5) * 80,
                    (Math.random() - 0.5) * 80
                );

                // Target position (tr√™n c√¢y, h∆°i ra ngo√†i)
                const h = Math.random() * CONFIG.tree.height;
                const y = h - CONFIG.tree.height / 2;
                const normalizedY = h / CONFIG.tree.height;
                const radius = (CONFIG.tree.radius * (1 - normalizedY)) + 0.5;
                const theta = Math.random() * Math.PI * 2;

                light.userData.targetPos = new THREE.Vector3(
                    radius * Math.cos(theta),
                    y,
                    radius * Math.sin(theta)
                );

                light.userData.blinkSpeed = 2 + Math.random() * 4;
                light.userData.blinkOffset = Math.random() * 100;
                light.userData.baseColor = color;

                light.position.copy(light.userData.chaosPos);

                lightsGroup.add(light);
            }

            scene.add(lightsGroup);
        }

        // ==========================================
        // 7. TOP STAR (3D Gold Star)
        // ==========================================
        function createTopStar() {
            // T·∫°o h√¨nh ng√¥i sao 5 c√°nh
            const starShape = new THREE.Shape();
            const outerRadius = 4;
            const innerRadius = 2;
            const points = 5;

            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                if (i === 0) {
                    starShape.moveTo(radius * Math.cos(angle), radius * Math.sin(angle));
                } else {
                    starShape.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
                }
            }
            starShape.closePath();

            const extrudeSettings = {
                depth: 1,
                bevelEnabled: true,
                bevelThickness: 0.3,
                bevelSize: 0.3,
                bevelSegments: 3
            };

            const geometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);

            const material = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.gold,
                emissive: CONFIG.colors.gold,
                emissiveIntensity: 2,
                roughness: 0.1,
                metalness: 1.0
            });

            starMesh = new THREE.Mesh(geometry, material);
            starMesh.position.set(0, CONFIG.tree.height / 2 + 5, 0);
            starMesh.rotation.x = Math.PI / 2;
            starMesh.scale.set(0, 0, 0); // B·∫Øt ƒë·∫ßu ·∫©n

            scene.add(starMesh);
        }

        // ==========================================
        // 8. SNOWFALL
        // ==========================================
        function createSnowfall() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.counts.snowflakes;
            const positions = new Float32Array(count * 3);
            const velocities = [];

            for (let i = 0; i < count; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 1] = Math.random() * 150 - 25;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 200;

                velocities.push({
                    x: (Math.random() - 0.5) * 0.02,
                    y: -0.1 - Math.random() * 0.1,
                    z: (Math.random() - 0.5) * 0.02
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.userData = { velocities };

            const material = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const snow = new THREE.Points(geometry, material);
            snow.name = 'snowfall';
            scene.add(snow);
        }

        // ==========================================
        // 9. MAGIC DUST (Sparkles around tree)
        // ==========================================
        function createMagicDust() {
            const geometry = new THREE.BufferGeometry();
            const count = 300;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const y = (Math.random() - 0.5) * CONFIG.tree.height;
                const r = 40 + Math.random() * 20;

                positions[i * 3] = r * Math.cos(theta);
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = r * Math.sin(theta);

                // Gold/Silver sparkles
                const isGold = Math.random() > 0.5;
                colors[i * 3] = isGold ? 1 : 0.9;
                colors[i * 3 + 1] = isGold ? 0.84 : 0.9;
                colors[i * 3 + 2] = isGold ? 0 : 0.9;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                transparent: true,
                opacity: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            const dust = new THREE.Points(geometry, material);
            dust.name = 'magicDust';
            scene.add(dust);
        }

        // ==========================================
        // 10. ANIMATION LOOP
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const delta = 0.016; // ~60fps

            const isFormed = state === 'FORMED';

            // === Update Foliage ===
            if (foliageSystem) {
                const positions = foliageSystem.geometry.attributes.position.array;
                const targets = foliageSystem.geometry.userData.targetPositions;
                const velocities = foliageSystem.geometry.userData.velocities;
                const phases = foliageSystem.geometry.userData.phases;
                const count = positions.length / 3;

                // Breathing effect
                const breathScale = 1 + Math.sin(time * 1.2) * 0.05;

                for (let i = 0; i < count; i++) {
                    const idx = i * 3;

                    if (isFormed) {
                        // Lerp to tree shape with breathing
                        const targetX = targets[idx] * breathScale;
                        const targetY = targets[idx + 1];
                        const targetZ = targets[idx + 2] * breathScale;

                        // Th√™m chuy·ªÉn ƒë·ªông s√≥ng nh·∫π
                        const wave = Math.sin(time * 2 + phases[i]) * 0.3;

                        velocities[idx] = velocities[idx] * 0.92 + (targetX + wave - positions[idx]) * 0.08;
                        velocities[idx + 1] = velocities[idx + 1] * 0.92 + (targetY - positions[idx + 1]) * 0.08;
                        velocities[idx + 2] = velocities[idx + 2] * 0.92 + (targetZ + wave - positions[idx + 2]) * 0.08;
                    } else {
                        // Chaos - xoay tr√≤n v√† lan t·ªèa
                        const chaos = 60;
                        const angle = time * 0.5 + phases[i];
                        const chaosX = Math.sin(angle) * chaos * Math.sin(phases[i]);
                        const chaosY = Math.cos(angle * 0.7) * chaos * 0.5;
                        const chaosZ = Math.cos(angle) * chaos * Math.cos(phases[i]);

                        velocities[idx] = velocities[idx] * 0.95 + (chaosX - positions[idx]) * 0.02;
                        velocities[idx + 1] = velocities[idx + 1] * 0.95 + (chaosY - positions[idx + 1]) * 0.02;
                        velocities[idx + 2] = velocities[idx + 2] * 0.95 + (chaosZ - positions[idx + 2]) * 0.02;
                    }

                    positions[idx] += velocities[idx];
                    positions[idx + 1] += velocities[idx + 1];
                    positions[idx + 2] += velocities[idx + 2];
                }

                foliageSystem.geometry.attributes.position.needsUpdate = true;
                foliageSystem.rotation.y += isFormed ? 0.002 : 0.005;
            }

            // === Update Ornaments ===
            if (ornamentsGroup) {
                ornamentsGroup.children.forEach(mesh => {
                    const target = isFormed ? mesh.userData.targetPos : mesh.userData.chaosPos;
                    mesh.position.lerp(target, delta * 2);

                    mesh.rotation.x += mesh.userData.rotSpeed.x * delta;
                    mesh.rotation.y += mesh.userData.rotSpeed.y * delta;
                    mesh.rotation.z += mesh.userData.rotSpeed.z * delta;
                });
            }

            // === Update Fairy Lights ===
            if (lightsGroup) {
                lightsGroup.children.forEach(light => {
                    const target = isFormed ? light.userData.targetPos : light.userData.chaosPos;
                    light.position.lerp(target, delta * 2);

                    // Blinking effect
                    const blink = (Math.sin(time * light.userData.blinkSpeed + light.userData.blinkOffset) + 1) / 2;
                    light.material.emissiveIntensity = isFormed ? 2 + blink * 5 : 0.5;
                    light.material.opacity = isFormed ? 0.8 + blink * 0.2 : 0.5;
                });
            }

            // === Update Top Star ===
            if (starMesh) {
                const targetScale = isFormed ? 1 : 0;
                starMesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), delta * 3);
                starMesh.rotation.z += delta * 0.5;

                // Glow effect
                if (starMesh.material) {
                    starMesh.material.emissiveIntensity = 1.5 + Math.sin(time * 3) * 0.5;
                }
            }

            // === Update Snowfall ===
            const snow = scene.getObjectByName('snowfall');
            if (snow) {
                const positions = snow.geometry.attributes.position.array;
                const velocities = snow.geometry.userData.velocities;

                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3] += velocities[i].x;
                    positions[i * 3 + 1] += velocities[i].y;
                    positions[i * 3 + 2] += velocities[i].z;

                    // Reset snowflake if it falls too low
                    if (positions[i * 3 + 1] < -50) {
                        positions[i * 3 + 1] = 100;
                        positions[i * 3] = (Math.random() - 0.5) * 200;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                    }
                }

                snow.geometry.attributes.position.needsUpdate = true;
            }

            // === Update Magic Dust ===
            const dust = scene.getObjectByName('magicDust');
            if (dust) {
                dust.rotation.y += 0.003;
                dust.material.opacity = 0.4 + Math.sin(time * 2) * 0.2;
            }

            // === Update State Indicator ===
            document.getElementById('state-indicator').textContent =
                isFormed ? 'üéÑ FORMED - Merry Christmas!' : '‚ú® CHAOS - Wave to assemble!';

            renderer.render(scene, camera);
        }

        // ==========================================
        // 11. HAND GESTURE CONTROL
        // ==========================================
        function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            bgMusic.play().catch(e => console.log(e));
            init3D();

            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');

            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

            hands.onResults(results => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

                // Heart gesture (2 hands)
                if (results.multiHandLandmarks.length === 2) {
                    const h1 = results.multiHandLandmarks[0];
                    const h2 = results.multiHandLandmarks[1];
                    const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    if (distIndex < 0.15 && distThumb < 0.15) {
                        // Love mode - could add special effect here
                        return;
                    }
                }

                if (results.multiHandLandmarks.length > 0) {
                    hasHandDetected = true;
                    const lm = results.multiHandLandmarks[0];
                    handX = lm[9].x;

                    const tips = [8, 12, 16, 20];
                    const wrist = lm[0];
                    let openDist = 0;
                    tips.forEach(i => openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y));
                    const avgDist = openDist / 4;

                    // Fist = FORMED, Open Palm = CHAOS
                    if (avgDist < 0.25) {
                        state = 'FORMED';
                    } else {
                        state = 'CHAOS';
                    }
                } else {
                    hasHandDetected = false;
                }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({ image: video }); },
                width: 640, height: 480
            });
            cameraUtils.start();
        }

        // ==========================================
        // 12. RESIZE HANDLER
        // ==========================================
        window.addEventListener('resize', () => {
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Keyboard control fallback
        window.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Enter') {
                state = state === 'CHAOS' ? 'FORMED' : 'CHAOS';
            }
        });
    </script>
</body>

</html>